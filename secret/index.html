<!DOCTYPE html>
<meta charset="utf-8">
<title>Embedding a notebook that uses a Secret</title>
<link rel="stylesheet" type="text/css" href="./inspector.css">
<style>

body {
  max-width: 960px;
  margin: 1em auto;
  font-family: sans-serif;
}

</style>
<body>

<h1><a href="https://github.com/observablehq/examples">Observable Example</a>: <a href="https://github.com/observablehq/examples/tree/main/secret">Secret</a></h1>

<p>This example demonstrates overriding <a href="https://observablehq.com/@observablehq/secrets">Secrets</a> with your own implementation.</p>

<script type="module">

import define from "./index.js";
import {Runtime, Library, Inspector} from "./runtime.js";

// This is an *insecure* example of how to use your own implementation of the
// built-in Secret function by getting values from a hardcoded Map. Note that
// our `Secret` is a function that returns the function that gets called by the
// cell; the runtime documentation https://github.com/observablehq/runtime says:

// > If you wish for the value of a builtin to be a function, the builtin must
// > be defined either as a promise that resolves to a function or as a function
// > that returns a function. Builtins may also be defined as generators for
// > dynamic valuesâ€¦

const secrets = new Map([["MY_SECRET_KEY", "$w0rdf1sh"]]);
const Secret = () => key => secrets.get(key);

// When we initialize the runtime, we pass it a standard Library object, with
// `Secret` overridden with our custom implementation. Now, when a cell calls
// Secret("MY_SECRET_KEY"), it will return "$w0rdf1sh".

const runtime = new Runtime(Object.assign(new Library, {Secret}));

const main = runtime.module(define, Inspector.into(document.body));

</script>
